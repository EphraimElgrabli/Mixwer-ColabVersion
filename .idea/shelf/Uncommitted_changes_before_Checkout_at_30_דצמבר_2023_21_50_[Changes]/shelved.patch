Index: exportPng.py
===================================================================
diff --git a/exportPng.py b/exportPng.py
deleted file mode 100644
--- a/exportPng.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,123 +0,0 @@
-import cv2
-import editBox
-import editFiles
-import listFinds
-from PIL import Image, ImageDraw
-
-Qsign = "שאלה מספר"
-
-
-def export_questions(array_path, ouput_directory):
-    HEIGHT_BEGIN_Q = 140
-    questions_paths = []
-    general_num_Q = 1
-    first_Q = False
-    for img in array_path:
-        lastQ = False
-        page_num_Q = 1
-        open_img = cv2.imread(img)
-        first_words = listFinds.find_first_words(img, [Qsign], False, True)
-        if first_words['text'].count(Qsign) == 0:  # If Qsign still doesn't appear, continue to the next page
-            if not first_Q:
-                continue
-            else:
-                lastQ = True
-        while not lastQ:
-            first_Q = True
-            coordCurrent = editBox.wordToBox(Qsign, first_words, [Qsign], page_num_Q)
-            if page_num_Q < first_words['text'].count(Qsign):
-                coordNext = editBox.wordToBox(Qsign, first_words, [Qsign], page_num_Q + 1)
-                '''if (coordCurrent[1] > 10):  # relevant only for the first Q
-                    cropped_image = open_img[coordCurrent[1] - 10:coordNext[1] - 10, 0:open_img.shape[1]]
-                else:
-                    cropped_image = open_img[coordCurrent[1]:coordNext[1] - 10, 0:open_img.shape[1]]'''
-                cropped_image = open_img[coordCurrent[1]:coordNext[1] - 10, 0:open_img.shape[1]]
-            else:
-                lastQ = True  # last q in the page
-                if coordCurrent[1] > 10:
-                    cropped_image = open_img[coordCurrent[1] - 10:open_img.shape[0], 0:open_img.shape[1]]
-                else:
-                    cropped_image = open_img[coordCurrent[1]:open_img.shape[0], 0:open_img.shape[1]]
-            path = ouput_directory + 'question_{}.png'.format(general_num_Q)
-            cv2.imwrite(path, cropped_image)
-            questions_paths.append(path)
-            general_num_Q += 1
-            page_num_Q += 1
-
-        ''' Check if some answers of the previous page there are in the begining of the page.
-            if: There are something above the first q (probably a continue of the previous q)
-                and this is not the last q 
-        '''
-        if first_words['text'].count(Qsign) != 0 \
-                and editBox.wordToBox(Qsign, first_words, [Qsign], 1)[1] > HEIGHT_BEGIN_Q \
-                and general_num_Q > page_num_Q \
-                or first_words['text'].count(Qsign) == 0:
-            if first_words['text'].count(Qsign) != 0:
-                coordCurrent = editBox.wordToBox(Qsign, first_words, [Qsign], 1)
-            else:
-                coordCurrent = [0, open_img.shape[0], 0, 0]
-            cropped_image = open_img[0:coordCurrent[1], 0:open_img.shape[1]]
-            path = ouput_directory + 'continue_question_{}.png'.format(general_num_Q - page_num_Q)
-            cv2.imwrite(path, cropped_image)
-
-            merge_png = [ouput_directory + 'question_{}.png'.format(general_num_Q - page_num_Q)
-                , path]
-            editFiles.combineFiles(merge_png
-                                   , ouput_directory + 'question_{}'.format(general_num_Q - page_num_Q))
-
-    return questions_paths, general_num_Q - 1
-
-
-def export_answers(pathRoot, answersId, ouput_directory):
-    image = cv2.imread(pathRoot)
-    first_words = listFinds.find_first_words(pathRoot, answersId, False)
-    halfPath = pathRoot[pathRoot.rfind("\\") + 1:]
-    numQ = int(halfPath[9:-4])
-    if numQ == 10:
-        pass
-    coordNext = []
-    try:
-        for charAns in answersId[1:]:
-            if charAns == answersId[1]:
-                coordNext = [0, 10, 0, 0]
-            coordCurrent = coordNext
-            #If it is the last answer in the qestion
-            if charAns != answersId[-1]:
-                try:
-                    coordNext = editBox.wordToBox(charAns, first_words, answersId)
-                except:
-                    #Crop the image from the begin of the last A, in order to make OCR read better
-                    cropped_image = image[coordCurrent[1] - 10:image.shape[0], 0:image.shape[1]]
-
-                    cv2.imwrite(pathRoot, cropped_image)
-                    image = cv2.imread(pathRoot)
-                    first_words = listFinds.find_first_words(pathRoot, answersId, False)
-
-                    coordNext = editBox.wordToBox(charAns, first_words, answersId)
-            else:
-                coordNext = [image.shape[1], image.shape[0], image.shape[1], image.shape[0]]
-            cropped_image = image[coordCurrent[1] - 10:coordNext[1] - 10, 0:image.shape[1]]
-            try:
-                if charAns != answersId[1]:
-                    pathC = ouput_directory + 'question_{}_answer_{}.png'.format(numQ, answersId.index(charAns) - 1)
-                else:
-                    pathC = ouput_directory + 'question_{}_prefix.png'.format(numQ)
-                cv2.imwrite(pathC, cropped_image)
-            except:
-                cv2.imwrite(pathC, image[0:30, 0:image.shape[1]])
-                print(fr"ERROR question - {numQ} answer - {answersId.index(charAns)}")
-    except:
-        print(fr"ERROR question - {numQ} - fill with white")
-    '''     width = 1700
-        height = 100
-        background_color = (255, 255, 255)  # White color in RGB
-        image = Image.new('RGB', (width, height), background_color)
-
-        for charAns in answersId[1:]:
-            # Save the image as a PNG file
-            if charAns != answersId[1]:
-                path = ouput_directory + 'question_{}_answer_{}.png'.format(numQ, answersId.index(charAns) - 1)
-            else:
-                path = ouput_directory + 'question_{}_prefix.png'.format(numQ)
-            image.save(path)
-   '''
Index: modified.txt
===================================================================
diff --git a/modified.txt b/modified.txt
deleted file mode 100644
--- a/modified.txt	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,242 +0,0 @@
-
-
-
-* �� �����: �"� ����, ���� ����, ��� ������		
-* ����� ������:	       22/ 7 /26  	                                                     
-* ��� ������ (�����):	180	 
-* ���� ��� ���� ������:  ���
-* ������: ����
-* ����� ���� 12 ����� ��"� :   8  ����� ��������� �- 4 ����� ������,  �� ����� �� �� �����.	
-* �� ������� �� ����� ���� �������, ��� ������ ���� ������ �� ������.
-* ����� ����� ���� ���� �� ������.
-
-
-* ����� �����: 
-o �� ���� �������� -  6 ������
-o �� ���� ����� -  13 ������
-����� ���, 
-1. ���� ������� �� ����� ������ �� ����� ����, �������� ������ ������� - ����� ����� ������ �� �� ����� ������.
-2. �� ���� ���� �� ����� ����� ����� �����, ���� ����� ���� ������ ���� ���� ���� �� ����� ������ �����. ����� ����� ��� �� ���� ����� �� ��� ���� �����.
-3. �������, ������ ������ �� �� �� ������, ��� �� �� ������ �� ���������, ���� ����� ���� ������, ���� ��� ������ ��-������, ���� ����� ����� �� ������.
-               
-         ������ ���   
-
-���� 1: 
-��� ������ ���"� ����� ����?
-Agg. ����� ����� �� ����� ��� ��� ������ ��� ��� ����� ���� ������ 
-B. ����� ����� ��� ������ ����� �� ������ �� ��� ������ ���, ��� ���� �������, ���������� �� ��� �����.
-�. �� ��� ������� ����� ������ ���� �� ���� ��� ���� ���"�
-�. ����� ����� �� ����� ��� ��� � 5 ����� �� ������ ��� ���� ����� ��� ������
-
-���� 2: 
-����� �� task scheduling  ����� � WBS  work breakdown structure   ����� ���
-�. ���� ��� ������� ��� ������� ��� ������ ���� ��
-�. ���� ���� ������ ������ ������� ����� ��� ��� ������ �� �� �����
-�. ���� ��� �deadline ������ �������
-�. ���� ���� ����� ���� ��� �����
-
-���� 3: 
-�� ����� ������ �� �� ������ � DFD �� ����� ����� �������� ����� �����. 
-�� ���� ������� ����� ����?
-�. ���� ���� ������ ������ ����
-�. ���� ����� ��������� �DFD3 ���� ����� ���� ������ ������ ��� �����
-�. ������� 2.3 � DFD2 ��� �������� "���"
-�. ���� ���� ������ � connectors 
-
-���� 4: 
-��� ���� Jenkin ?
-�. ����� ������ ������ ������
-�. ����� � continuous integration � continuous delivery
-�. ����� ������ ��� ��� ���� �� �����
-�.  ����� ����� ��������� ������� ����� �����
-
-
-
-
-
-
-���� 5: 
-���� ����� activity . 
-
-��� ������� (�������) �� ������?
-�. ����� �������
-�. ����� ���
-�. ��� �������
-�. ����� �������
-
-
-
-
-
-
-���� 6: 
-�� ������ ����� "��� ����" ����� ���� ��� ����?
-�. �� ����� ���� �����
-�. ����� "��� ����" ������ ������ ������ ����� ������� ����� ��� ����
-�. ����� "��� ����" ����� ���� ����� ��� ���� ���� ����� ��� ����
-�. ����� "��� ����" �� ���� ���� ���� �� ������� ������� ����� ������ ������ ������� ���� ��� ������.
-
-���� 7: 
-�� ���� ���� ������ ��������� ��� ����� SCRUM?
-�. ����� ������ ������, ���� ���, ��� ������� �� ���� ���� ������ ����� �������� � product Owner
-�. ����� ������ ������� ������, ���� ,  �� ����� ����� ����
-�. ����� ������ ������, ���� ���, ��� ������� �� ���� ���� ������ ����� �������� � scrum master
-�. ����� ������ ������� ������, ���� ,  �� ����� �����. � product Owner ��  scrum master
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-���� 8: 
-task scheduling:
-���� ��� ��������. �� �� ������ ���� ��� ��� ������ ���. 
-�� ������ ���� ��� ����� ��� �2  ������ ���. ������� ����� �� ������� ��� ����� ���. ���� ����� ��� ����� ������ ������ ��� ������ ���? 
-�. T10
-�. �� ��� ������ ������
-�. T7
-�. T3
-
-��� ����
-���� 9: 
-���� ������ ���� �������� ���������� ��� ��� �� ����� �����
-��� �������� weighing factor
-���� ��������
-
-Low(Simple)
-25
-EI
-Aggverage
-30
-EO
-High(Complex)
-20
-EQ
-Low(Simple)
-20
-EQ
-Aggverage
-100
-ILF
-Aggverage
-50
-EIF
- 
-��� �� ������ � complexity factors:
-fi
-complexity factor number
-Moderate
-1
-Aggverage
-2
-Aggverage
-3
-Aggverage
-4
-Moderate
-5
-Moderate
-6
-Significant
-7
-Moderate
-8
-Moderate
-9
-Significant
-10
-Significant
-11
-Moderate
-12
-Aggverage
-13
-Moderate
-14
-
-��� ���� �� � function points . �� ���� �� ������ ������� �� ���� ����� ����� �������. �� ������ ������ � CAggF ������. 
-
-
-���� 10: 
-��� ����/�� ���� ����� ���� ���� �-DFD: 
-1) ��� ������ ��� ���� ������� ����� ������ �����.                 ���� / �� ����  
-2) ��� ������ ��� ���� ������� ��������.                               ���� / �� ����   
-3) ��� ������ ��� ��� ����� ������ �������.                            ���� / �� ����    
-4) ��� ������ ��� ��� ������ ��������.                                   ���� / �� ����  
-5) ��� ������ ��� ��� ��������                                             ���� / �� ����     
-6) ��� ������ ��� ������� ����� ������ ������                        ���� / �� ����       
-
-���� 11: 
-�� ����� �� ����� ���� �� �� ������ COCOMO.
-����� ����� ������ ���� �� ���� �� ���� ������ �� ������. ����� ����� ����� �� ����� ������.  ������  ������ � 40k LOC.
-
-������ ������ : ������ -  ���� ����, ������ ��� ����� � ����.
-�� ��� ������ ������ �������. 
-
-��� ���� ������ 15,000 � �����. ��� ������ ����� �� ����� �� ��� ������ ������ ��� ���� �� ����� (���� �� , �� ���� �� ����� ����� ��� , ����� ��� ���� ����� ����� ���� ��, ���� ���� ��� ���� ��� ����� ���. 
-
-�� ����� �� ������ ���� �� ������ �����.
-
-
-���� 12:
-���� ����� ������ �� ����� ������:
-������ ����� ������ ������� ��� ���� ������ "����" . 
-���� ������ ���� ������ ����� ����, ����� ������ ������� ��� �� ���� ����� ����� ���� ������ ����� ����. �� ����� ����� ���� ���� ���� ���� ������. ����� ���� ���� ���� ����� ������ ��� . �� �������� ���� ����� ����� ���� ������ ���� ����� ����� ������� ��������. ����� ����� ��� ����. �������� ���� ����� ����� ���� ����� ���� ��, ��� ������ �����. �� ����� ���� ���� ���� ����� ���� ���� ���� ��. ���� ����� ���� ���� ���� ����� �� ���� ���� ��. 
- 
-�� ����� use case diagram ����� �������.
-
-
-������!
-
-
-
-
-����� ����:
-
-
-
-
-������� FP
-��� ������� ������
-
-
-
-CAggF = [0.65 + 0.01 *?(fi)]
-
-����� FP �����
-
-
-
-
-
-��"�
- 
-���"� ���"�, ����� �, ���� �
-����� ����� �����: ����� �����
- ���� ����: 151060
-
-
-���� 1 ���� 11
-
-
-���"� ���"�, ����� �, ���� �
-����� ����� �����: ����� �����
- ���� ����: 151060
-
-
Index: editPng.py
===================================================================
diff --git a/editPng.py b/editPng.py
deleted file mode 100644
--- a/editPng.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,241 +0,0 @@
-import cv2
-import numpy as np
-from PIL import Image, ImageDraw, ImageFont
-
-import editFiles
-
-
-def is_image_all_white(image_path):
-    try:
-        # Open the image
-        image = Image.open(image_path)
-
-        # Get the image dimensions
-        width, height = image.size
-
-        # Define the white color in RGB format
-        white_color = (255, 255, 255)
-
-        # Iterate through each pixel in the image
-        for x in range(width):
-            for y in range(height):
-                pixel_color = image.getpixel((x, y))
-                if pixel_color != white_color:
-                    return False  # Found a non-white pixel
-
-        # If all pixels are white, return True
-        return True
-    except Exception as e:
-        print(f"Error: {e}")
-        return False  # Handle any exceptions by returning False
-
-
-def reCrop():
-    ouput_directory,list_files = editFiles.getFilesPaths()
-    for pathC in enumerate(list_files):
-        if "answer" in pathC[1] or "prefix" in pathC[1]:
-            cropSpaceEndPng(editFiles.getOutputDirectoryPath()+pathC[1])#TODO pathC[1]
-
-def lastWhiteLineCoordPng(path):
-    img = cv2.imread(path)
-    # Convert the image to grayscale
-    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
-    # Set the threshold for what is considered white
-    white_threshold = 255
-    # Get the shape of the image
-    height, width = gray.shape
-    # Calculate the average intensity for each row
-    avg_intensity = [sum(row) / width for row in gray]
-
-    # Find the first row where the average intensity is less than the threshold
-    for i, intensity in enumerate(avg_intensity[::-1]):
-        if intensity < white_threshold:
-            return height - i
-    return 0
-
-
-def firstNotWhiteLineCoordPng(path, bigSpace, contiueSearchBigSpace):
-    image = cv2.imread(path)
-    # Convert the image to grayscale
-    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
-    # Get the shape of the image
-    height, width = gray.shape
-    # Set the threshold for what is considered white
-    white_threshold = 255
-    # Calculate the average intensity for each row
-    end = min(1000, height)
-    avg_intensity = [sum(row) / width for row in gray[20:end]]
-
-    # Find the first row where the average intensity is less than the threshold
-    i = 1
-    while i < len(avg_intensity):
-        isThisEnoughBigSpace = True
-        if avg_intensity[i] == white_threshold:
-            j = i
-            while j < len(avg_intensity) and isThisEnoughBigSpace:
-                if j < i + bigSpace and avg_intensity[j] != white_threshold:
-                    isThisEnoughBigSpace = False
-                    i = j
-                    if not contiueSearchBigSpace:
-                        break
-                if not contiueSearchBigSpace:
-                    if j > i + bigSpace and isThisEnoughBigSpace and avg_intensity[j] != white_threshold:
-                        return j + 20
-                else:
-                    if j > i + bigSpace and isThisEnoughBigSpace and avg_intensity[j] == white_threshold:
-                        return i
-                j += 1
-            if not isThisEnoughBigSpace and not contiueSearchBigSpace:
-                break
-
-        i += 1
-    return False
-
-
-def cropSpaceEndPng(path):
-    image = cv2.imread(path)
-    height = lastWhiteLineCoordPng(path)
-    cropped = image[:height + 10, :]
-    cv2.imwrite(path, cropped)
-
-
-def cropSpaceAnswerPng(path, mid=False):
-    image = cv2.imread(path)
-    height = firstNotWhiteLineCoordPng(path, 20, mid)
-    if not height:
-        return
-    if not mid:
-        cropped = np.vstack((image[0:30, :], image[height:, :]))
-    if mid:
-        cropped = image[:height + 20, :]
-    cv2.imwrite(path, cropped)
-
-
-# Add the number of Answer to Png
-def rewriteAnswer(path, i, location):
-    text = ".{}".format(i)
-    text_height, _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 1, 2)[0]
-    imageQ = cv2.imread(path)
-    cv2.rectangle(imageQ, (location, 0),
-                  (imageQ.shape[1], imageQ.shape[0]), (255, 255, 255), -1)
-    cv2.imwrite(path, imageQ)
-    cv2.putText(imageQ, text, (1530, 25), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 0), 2, cv2.LINE_AA)
-    cv2.imwrite(path, imageQ)
-
-
-def createAnswersPage(path_answers):
-    PAGE_HEIGHT = 1805
-    PAGE_WIDTH = 1700
-    image_array = []
-    num_answer = 1
-    prefix_path = path_answers[1][:path_answers[1].rfind("\\") + 1]
-    current_path = ""
-
-    num_q = 0
-    for cpath in path_answers:
-        pathEnd = cpath[cpath.rfind("_") + 1:-4]
-        if pathEnd == 'prefix':
-            num_answer = 1
-        elif pathEnd == '1':
-            num_q = cpath[cpath.find("_") + 1:cpath.rfind("_") - 7]
-            blank = Image.new("RGBA", (PAGE_WIDTH, 70), (255, 255, 255, 255))
-            text = "Question {} : Answer {}".format(num_q
-                                   , num_answer)
-            font = ImageFont.truetype('arial.ttf', 40)
-            draw = ImageDraw.Draw(blank)
-            text_width, text_height = draw.textsize(text, font=font)
-
-            text_x = (PAGE_WIDTH - text_width) / 2
-            text_y = (70 - text_height) / 2
-
-            # Draw text on the image
-            draw.text((text_x, text_y), text, fill=(0, 0, 0), font=font)
-            current_path = prefix_path + fr"answer_{num_q}.png"
-            blank.save(current_path)
-            image_array.append(current_path)
-        try:
-            int(pathEnd)
-            num_answer += 1
-        except:
-            pass
-
-    return editFiles.combineFilestoPages(image_array, prefix_path, "AnswerPage"), image_array
-
-#if the Q is more than a page we need to split it
-def crop_png_middle(path_to_png, start_coord,search_height=70,noWhite=False):
-    img = Image.open(path_to_png)
-    width, height = img.size
-
-    if noWhite:
-        split_y = start_coord
-    else:
-        # Define the starting point and height for the search
-        start_y = start_coord
-
-
-        # Iterate through the image and find the white lines
-        white_lines = []
-        try:
-            for y in range(start_y, height):
-                line = img.crop((0, y, width, y + 1))
-                avg_color = tuple(map(int, line.resize((1, 1)).getpixel((0, 0))))
-                if avg_color == (255, 255, 255):
-                    white_lines.append(y)
-                else:
-                    white_lines.clear()
-                if len(white_lines) == search_height:
-                    break
-        except:
-            return False
-
-        # If no white lines were found, return the original image
-        if not len(white_lines) == search_height:
-            return False
-
-        if not white_lines[0] + 10 < height:
-            return False
-
-        # Otherwise, split the image at the first white line found
-        split_y = white_lines[0]
-
-    top_img = img.crop((0, 0, width, split_y+10))
-    bottom_img = img.crop((0, split_y+10, width, height))
-
-    # Save the cropped images to disk
-    top_img.save(path_to_png[:path_to_png.rfind(".")]+"_top.png" )
-    bottom_img.save(path_to_png[:path_to_png.rfind(".")]+"_bottom.png")
-    return [path_to_png[:path_to_png.rfind(".")]+"_top.png",path_to_png[:path_to_png.rfind(".")]+"_bottom.png"]
-
-
-def rightmost_non_white_black_pixel(path):
-    # Open the image
-    image = Image.open(path)
-
-    # Get image width and height
-    width, height = image.size
-    flagA,flagB,flagC =False,False,False
-    # Start from the rightmost column and move towards the left
-    for x in range(width - 1, -1, -1):
-        col_sum = [0, 0, 0]
-        for y in range(height):
-            pixel_value = image.getpixel((x, y))
-            col_sum[0] += pixel_value[0]  # Red channel
-            col_sum[1] += pixel_value[1]  # Green channel
-            col_sum[2] += pixel_value[2]  # Blue channel
-
-        # Calculate the average for each color channel
-        avg_r = col_sum[0] / height
-        avg_g = col_sum[1] / height
-        avg_b = col_sum[2] / height
-
-        # Check if the average of the column is not purely white (255, 255, 255)
-        if avg_r < 255 or avg_g < 255 or avg_b < 255:
-            flagA = True
-        if flagA and avg_r == 255 and avg_g == 255 and avg_b == 255:
-            flagB = True
-        if flagA and flagB and (avg_r < 255 or avg_g < 255 or avg_b < 255):
-            flagC = True
-        if flagA and flagB and flagC and avg_r == 255 and avg_g == 255 and avg_b == 255:
-            return x
-
-            # Find the rightmost non-white black pixel in the column
Index: AnswerMixer.py
===================================================================
diff --git a/AnswerMixer.py b/AnswerMixer.py
deleted file mode 100644
--- a/AnswerMixer.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,165 +0,0 @@
-import re
-
-
-import editFiles
-
-import exportPng
-import listFinds
-import editPng
-import editBox
-import numpy as np
-
-successPdf = []
-athOfPdf = ""
-answersId = []
-pageCode = True
-detailsBetweenQ = False
-# input_directory = "C:\\Users\\izeik\\Pictures\\אוטומטים לא מעורבל\\"
-ouput_directory = editFiles.getOutputDirectoryPath()
-
-
-def mixfiles():
-    directory_path, file_list = editFiles.getFilesPaths()
-
-    # Get a list of all files in the directory
-
-    # Create a list of file paths by joining the directory path with each file name
-
-    arrayAnswers = []
-    q = 1
-    while "question_{}.png".format(q) in file_list:
-        arrayAnswers.append([])
-        a = 1
-        while "question_{}_answer_{}.png".format(q, a) in file_list:
-            arrayAnswers[q - 1].append(directory_path + "question_{}_answer_{}.png".format(q, a))
-            a += 1
-        np.random.shuffle(arrayAnswers[q - 1])
-        q += 1
-
-    shuffleQuestions = []
-    q = 0
-    while "question_{}.png".format(q + 1) in file_list:
-        shuffleQuestions.append(directory_path + "question_{}_prefix.png".format(q + 1))
-        a = 0
-        while "question_{}_answer_{}.png".format(q + 1, a + 1) in file_list:
-            shuffleQuestions.append(arrayAnswers[q][a])
-            a += 1
-        q += 1
-
-    pattern = ouput_directory.replace("\\", "\\\\") + r"question_\d+_prefix.png"
-    i = 0
-    while i < len(shuffleQuestions):
-        isPerfix = re.fullmatch(pattern, shuffleQuestions[i])
-        if bool(isPerfix):
-            counterA = 1
-            i += 1
-            isPerfix = False
-            while i < len(shuffleQuestions) and not re.fullmatch(pattern, shuffleQuestions[i]):
-                if i == 40:
-                    pass
-                editPng.rewriteAnswer(shuffleQuestions[i], counterA,
-                                      editPng.rightmost_non_white_black_pixel(shuffleQuestions[i]))
-                counterA += 1
-                i += 1
-    i += 1
-    return shuffleQuestions
-
-    '''numQ = 1
-    for i in range(0, len(shuffleQuestions), numOfAnswers + 1):
-        if shuffleQuestions[i] == ouput_directory + "question_{}_prefix.png".format(numQ):
-            numQ += 1
-            for j in range(1, numOfAnswers + 1):
-                editPng.rewriteAnswer(shuffleQuestions[i + j], j,
-                                      editBox.rightFirstWordToBox(shuffleQuestions[i + j], answersId))
-'''
-
-
-def blendPdf():
-    # Convert test .pdf to page.png
-    path_originial_pages_png = editFiles.pdf_to_png(path_original_pdf, ouput_directory)
-
-    # TODO dont merge the pages because the ocr is less good, see what to do that it will be splited pages
-    # Merge the pages
-    pathOfMerge = editFiles.combineFiles(path_originial_pages_png, ouput_directory + 'result')
-
-    # Find how much q and a there are
-    # make each q to .png
-    arrayOfQuestions, numQ = exportPng.export_questions(path_originial_pages_png, ouput_directory)
-    print("Success export Q\n")
-    # make each a to .png
-    for pathQ in arrayOfQuestions:
-        global answersId
-        answersId = listFinds.findNumAnswers(pathQ)
-        exportPng.export_answers(pathQ, answersId, ouput_directory)
-        print("Success export A in Q {}\n".format(pathQ))
-
-    # crop each a
-    editPng.reCrop()
-    print("Success Croping\n")
-
-    # Mix the order of the answer
-    mixAnswers = mixfiles()
-    print("Success Mixing\n")
-    # Make answers and questions to pages .png
-    paths_of_pages = editFiles.combineFilestoPages(mixAnswers, ouput_directory)
-    print("Success final pages\n")
-
-    # Add answers page
-    answer_page_path, path_answers = editPng.createAnswersPage(mixAnswers)
-    paths_of_pages = paths_of_pages + answer_page_path
-    print("Success answer page\n")
-    # Make .png to .pdf
-    paths_of_pages_pdf = []
-    for current_page in paths_of_pages:
-        paths_of_pages_pdf.append(editFiles.png_to_pdf(current_page))
-    print("Success convert pages to.pdf\n")
-
-    ouput_pdf_path = ouput_directory + path_original_pdf[path_original_pdf.rfind("/") + 1:-4] + " מעורבל"
-    editFiles.merge_pdf(paths_of_pages_pdf,
-                        ouput_pdf_path)
-    print("Success merge pages\n")
-
-    editFiles.delete_files(path_originial_pages_png)
-    editFiles.delete_files(paths_of_pages)
-    editFiles.delete_files(path_answers)
-    editFiles.delete_files(arrayOfQuestions)
-    editFiles.delete_files(paths_of_pages_pdf)
-    editFiles.delete_files([ouput_directory + 'result.png'])
-    editFiles.delete_files(mixAnswers)
-
-    return ouput_pdf_path
-
-
-def main(array_paths):
-    '''
-    First conver the PDF to PNG files and combine and delete them.
-    The answers and questions are exported to PNG files.
-    We mix the answers and export to PDF
-    '''
-    global successPdf
-    successPdf = []
-    failPdf = []
-    for pdf_file_path in array_paths:
-        global path_original_pdf
-        path_original_pdf = pdf_file_path
-        fileNameEnd = path_original_pdf[path_original_pdf.rfind("\\") + 1:-4] + " מעורבל" + path_original_pdf[-4:]
-        try:
-            # zip all the successPdf
-            successPdf.append(blendPdf() + ".pdf")
-
-            print("SUCCESS {}".format(fileNameEnd))
-
-            # TODO:  delete all the rest files that not pdf
-        except Exception as e:
-            print("NOT  SUCCESS {}".format(fileNameEnd) + " ERROR: ", e)
-            failPdf.append(pdf_file_path)
-            # TODO send to the UI how many tests rest
-    return successPdf != []
-
-
-def zipPdf(zip_path):
-    editFiles.create_zip(successPdf, zip_path)
-
-
-if __name__ == "__main__":
-    main()
Index: editFiles.py
===================================================================
diff --git a/editFiles.py b/editFiles.py
deleted file mode 100644
--- a/editFiles.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,178 +0,0 @@
-from PIL import Image
-from pdf2image import convert_from_path
-import os
-from PyPDF4 import PdfFileMerger
-
-from PyPDF2 import PdfReader, PdfWriter
-import zipfile
-
-import editPng
-
-ouput_directory = 'C:\\Users\\izeik\\Pictures\\Mix\\'#TODO change to relative path
-
-
-def merge_pdf(arrayPath,nameFile):
-    merger = PdfFileMerger()
-    for pdf_file in arrayPath:
-        # Append PDF files
-        merger.append(pdf_file)
-
-    # Write out the merged PDF file_list
-    merger.write(nameFile+".pdf")
-    merger.close()
-def create_zip(files, zip_filename):
-    with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
-        for file in files:
-            # Get the base name of the file
-            base_name = os.path.basename(file)
-            # Add the file to the ZIP
-            zipf.write(file, arcname=base_name)
-
-    #return zip_filename
-
-
-#convert .png to .pdf
-def png_to_pdf(sourcePath):
-    png = Image.open(sourcePath)
-    im_1 = png.convert('RGB')
-    im_1.save(sourcePath[:-4]+".pdf")
-    return sourcePath[:-4]+".pdf"
-
-#Conver .pdf to .png and crop the begin and the end of the page
-def pdf_to_png(pathSource, pathDest):
-    pages = convert_from_path(pathSource)
-    paths = []
-    for i, page in enumerate(pages):
-        (width, height) = page.size
-        crop_box = (0, 0+150, width, height - 150)
-        page = page.crop(crop_box)
-        paths.append(pathDest + f'page_{i}.png')
-        page.save(pathDest + f'page_{i}.png', 'PNG')
-        editPng.cropSpaceEndPng(pathDest + f'page_{i}.png')
-    return paths
-
-
-def delete_files(paths):
-    for i in range(len(paths)):
-        os.remove(paths[i])
-
-def combineFiles(arrayPath,output_path):
-    # Load the images
-    images = [Image.open(path) for path in arrayPath]
-    # Determine the total size of the combined image
-    total_width = max(img.size[0] for img in images)
-    total_height = sum(img.size[1] for img in images)
-
-    # Create a new image to store the combined images
-    result = Image.new("RGBA", (total_width, total_height))
-
-    # Paste each image into the result
-    y_offset = 0
-    for img in images:
-        result.paste(img, (0, y_offset))
-        y_offset += img.size[1]
-
-    # Save the result
-    result.save(output_path+'.png')
-    return output_path+'.png'
-
-
-
-
-
-def combineFilestoPages(array_path, output_dir,prefixFile = "final_page"):
-    page_num = 1
-    total_height = 0
-    images_to_combine = []
-    total_page_path  = []
-    topAndBottonArray  = []
-    PAGE_HEIGHT = 1805
-    PAGE_WIDTH = 1700
-    BEGIN_HEIGHT = 200
-    for i, path in enumerate(array_path):
-        img = Image.open(path)
-        # Add white blank after every Q files
-        if path[path.rfind("_")+1:-4] == "prefix" and page_num != 1:
-            if total_height + 70 < PAGE_HEIGHT - BEGIN_HEIGHT:
-                padding = Image.new("RGBA", (PAGE_WIDTH, 70), (255, 255, 255, 255))
-                images_to_combine.append(padding)
-                total_height += padding.size[1]
-        #If the Q is bigger than page, we have to split it
-        if  img.size[1] > PAGE_HEIGHT-BEGIN_HEIGHT:
-            rest_page = PAGE_HEIGHT- total_height - BEGIN_HEIGHT
-            topAndBotton = editPng.crop_png_middle(path,int(rest_page/2))
-            if not topAndBotton:
-                topAndBotton = editPng.crop_png_middle(path,int(rest_page/2),25)
-            if not topAndBotton:
-                topAndBotton = editPng.crop_png_middle(path,int(rest_page/2),10)
-            if not topAndBotton:
-                topAndBotton = editPng.crop_png_middle(path,int(rest_page/2),0,True)
-            array_path.insert(i+1,topAndBotton[0])
-            array_path.insert(i+2,topAndBotton[1])
-            topAndBottonArray.insert(0,topAndBotton[0])
-            topAndBottonArray.insert(0,topAndBotton[1])
-
-            continue
-        if total_height + img.size[1] > PAGE_HEIGHT-BEGIN_HEIGHT:
-            # Add white padding to fill the remaining space in the page height
-            padding_height = PAGE_HEIGHT-BEGIN_HEIGHT - total_height
-            padding = Image.new("RGBA", (PAGE_WIDTH, padding_height), (255, 255, 255, 255))
-            images_to_combine.append(padding)
-            if page_num != 1:
-                padding = Image.open("beginPage.png")
-                images_to_combine.insert(0,padding)
-            else:
-                padding = Image.open("FirstbeginPage.png")
-                images_to_combine.insert(0,padding)
-
-            # Combine the images and save to a new file
-            result = Image.new("RGB", (PAGE_WIDTH, PAGE_HEIGHT), color = (255, 255, 255))
-            y_offset = 0
-            for imgtemp in images_to_combine:
-                result.paste(imgtemp, (0, y_offset))
-                y_offset += imgtemp.size[1]
-
-            output_path_current = os.path.join(output_dir, f"{prefixFile}_{page_num}.png")
-            result.save(output_path_current)
-
-            total_page_path.append(output_path_current)
-            # Reset the variables for the next page
-            page_num += 1
-            total_height = 0
-            images_to_combine = []
-
-        # Add the current image to the list of images to be combined
-        images_to_combine.append(img)
-        total_height += img.size[1]
-
-
-
-    # Check if there are any remaining images to be combined
-    if len(images_to_combine) > 0:
-        # Add white padding to fill the remaining space in the page height
-        padding_height = PAGE_HEIGHT - BEGIN_HEIGHT - total_height
-        padding = Image.new("RGBA", (PAGE_WIDTH, padding_height), (255, 255, 255, 255))
-        images_to_combine.append(padding)
-
-        padding = Image.open("beginPage.png")
-        images_to_combine.insert(0, padding)
-
-        # Combine the images and save to a new file
-        result = Image.new("RGBA", (PAGE_WIDTH, PAGE_HEIGHT),(255, 255, 255, 255))
-        y_offset = 0
-        for img in images_to_combine:
-            result.paste(img, (0, y_offset))
-            y_offset += img.size[1]
-
-        output_path_current = os.path.join(output_dir, f"{prefixFile}_{page_num}.png")
-        result.save(output_path_current)
-        total_page_path.append(output_path_current)
-        page_num += 1
-    return total_page_path
-
-
-def getFilesPaths():
-    return ouput_directory,os.listdir(ouput_directory)
-
-def getOutputDirectoryPath():
-    return ouput_directory
\ No newline at end of file
Index: editBox.py
===================================================================
diff --git a/editBox.py b/editBox.py
deleted file mode 100644
--- a/editBox.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,37 +0,0 @@
-import copy
-
-import pytesseract
-import cv2
-import listFinds
-
-
-def rightFirstWordToBox(path, answersId):
-    image = cv2.imread(path)
-    boxes = pytesseract.image_to_data(image, lang='eng+heb', config='--oem 2 --psm 6',
-                                      output_type=pytesseract.Output.DICT)
-    try:
-        return wordToBox(answersId[int(path[path.rfind("_") + 1:-4])], boxes, answersId, 1, True)[2]#TODO: go over and find the righest not white pixel
-    except:
-        return 1530
-
-
-def wordToBox(text, first_word_boxes, answersId, num=1, answer=False):
-    """
-
-    :param text: the word
-    :param first_word_boxes: The array
-    :param answersId: The
-    :param num: the num appearance of the word
-    :param answer: the array of optoinal array
-    :return: The coord of word[0(right),top,left,bottom]
-    """
-    value_first_word = copy.deepcopy(first_word_boxes)
-    words = value_first_word['text']
-    y = value_first_word['top']
-    l = first_word_boxes['left']
-    h = value_first_word['height']
-    if not answer:
-        start_index = listFinds.find_index(words, text, answersId, num)
-    else:
-        start_index = listFinds.find_index_answer(words)
-    return 0, y[start_index], l[start_index], y[start_index] + h[start_index]
Index: listFinds.py
===================================================================
diff --git a/listFinds.py b/listFinds.py
deleted file mode 100644
--- a/listFinds.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ /dev/null	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
@@ -1,162 +0,0 @@
-import numpy as np
-import pytesseract
-import cv2
-
-def find_index_correct_ocr(words,target_word):
-    if target_word in words:
-        return words.index(target_word)
-    return -1
-def find_index(words, target_word, answersId, num=1,skipBefore = False):
-    if target_word == answersId[0]:  # for "שאלה"
-        if words.count("שאלה" == 0):
-            return -1
-        arr = np.array(words)
-
-        x = np.where(arr == target_word)
-        return x[0][num - 1]
-        # return False
-    else:
-        '''if words.count(target_word) > 1:
-            arr = np.array(words)
-
-            x = np.where(arr == target_word)
-            return x[0][-1]
-        '''
-        if not target_word in words:
-            for i, word in enumerate(words):
-                if target_word[0] == word:
-                    return i
-            if answersId.index(target_word) == 1 or skipBefore:
-                index_before = -1
-            else:
-                index_before =find_index(words,answersId[answersId.index(target_word)-1],answersId)
-            try:
-                if target_word != answersId[-2]:
-                    index_after =find_index(words,answersId[answersId.index(target_word)+1],answersId,skipBefore=True)
-                    i = index_after
-                    while i > 0:
-                        if word != '' and target_word[0] in words[i][0]:
-                            return i
-                        i -= 1
-                else:
-                    i = index_before
-                    while i < len(words):
-                        if word != '' and target_word[0] in words[i][0]:
-                            return i
-                        i += 1
-            except:
-                pass
-            for i, word in enumerate(words):
-                if index_before < i and word in ["-",".","--","\\\\","(\\"]:
-                    return i
-            raise Exception("Not find {} in this image".format(target_word))
-        return words.index(target_word)
-
-def find_index_answer(words):
-    for i,word in enumerate(words):
-        if word == "":
-            pass
-        else:
-            return i
-def last_occurrence(word, array):
-    array_reversed = array[::-1]
-    try:
-        last_index = len(array) - 1 - array_reversed.index(word)
-        return last_index
-    except ValueError:
-        return -1
-
-def find_first_words(path, answersId=[], fromQ = True, disable_consecutive_q = False):
-    image = cv2.imread(path)
-    boxes = pytesseract.image_to_data(image, lang='heb', config='--oem 2 --psm 6',
-                                      output_type=pytesseract.Output.DICT)
-    # Filter only the first word in line
-    first_words_boxes = {'text': [], 'left': [], 'top': [], 'width': [], 'height': []}
-    line_number = -1
-    first_space = False
-    for i in range(len(boxes["text"])):
-        if boxes["text"][i] == "" and boxes["line_num"][i] != line_number:
-            first_space = True
-        elif boxes["text"][i] != "" and (first_space or boxes["line_num"][i] != line_number):
-            line_number = boxes["line_num"][i]
-            if boxes['text'][i] == "שאלה" and boxes['text'][i+1] == "מספר":
-                boxes['text'][i] = "שאלה מספר"
-            first_words_boxes['text'].append(boxes['text'][i])  # Extract the bounding boxes for each word
-            first_words_boxes['left'].append(boxes['left'][i])  # Extract the bounding boxes for each word
-            first_words_boxes['top'].append(boxes['top'][i])  # Extract the bounding boxes for each word
-            first_words_boxes['width'].append(boxes['width'][i])  # Extract the bounding boxes for each word
-            first_words_boxes['height'].append(boxes['height'][i])  # Extract the bounding boxes for each word
-            if first_space:
-                first_space = False
-
-    if fromQ:  # intilize the mistakes of ocr
-        start_first_words_from_Q(first_words_boxes, answersId)
-        for i in range(len(first_words_boxes['text'])):
-            for j in range(len(answersId) - 1):
-                if answersId[j] in first_words_boxes['text'][i]:
-                    first_words_boxes['text'][i] = answersId[j]
-                    break
-
-    if disable_consecutive_q:    # If "שאלה" after "שאלה" delete it
-        arr = np.array(first_words_boxes['text'])
-
-        x = np.where(arr == answersId[0])
-
-        for i in range(len(x[0]) - 1):
-            if x[0][i] + 1 == x[0][i + 1]:
-                first_words_boxes['text'][x[0][i + 1]] = ''
-
-    return first_words_boxes
-
-
-def start_first_words_from_Q(first_word_boxes, answersId):
-    index_first_q = find_index(first_word_boxes['text'], answersId[0], answersId)
-    first_word_boxes['text'] = first_word_boxes['text'][index_first_q:]  # Extract the bounding boxes for each word
-    first_word_boxes['left'] = first_word_boxes['left'][index_first_q:]  # Extract the bounding boxes for each word
-    first_word_boxes['top'] = first_word_boxes['top'][index_first_q:]  # Extract the bounding boxes for each word
-    first_word_boxes['width'] = first_word_boxes['width'][index_first_q:]  # Extract the bounding boxes for each word
-    first_word_boxes['height'] = first_word_boxes['height'][index_first_q:]
-    return first_word_boxes
-
-def isCorrectOCR(words):
-
-    if all(word in words for word in [ "א.", "ב.", "ג.", "ד."]) and all("\\" not in word for word in words):
-        return True
-    return False
-    #TODO continue
-def findNumAnswers(pathOfMerge):
-    first_words = find_first_words(pathOfMerge, [], False)
-    if isCorrectOCR(first_words['text']):
-        indexH = find_index_correct_ocr(first_words['text'],"ה.")
-        indexD = find_index_correct_ocr(first_words['text'],"ד.")
-        indexB = find_index_correct_ocr(first_words['text'],"ב.")
-        if indexH != -1:
-            return ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "ה.", "A"]
-        elif indexD != -1:
-            return ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "A"]
-        else:
-            return ["שאלה מספר", "א.", "ב.", "A"]
-
-
-    try:
-        indexH = find_index(first_words['text'], "ה.",
-                      ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "ה.", "A"])
-        indexD = find_index(first_words['text'], "ד.",
-                      ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "ה.", "A"])
-        indexB = find_index(first_words['text'], "ב.",
-                      ["שאלה מספר", "א.", "ב.", "A"])
-        if  indexH != -1 and indexD < indexH:
-            return ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "ה.", "A"]
-        if indexB != -1 and indexD == -1 and indexH == -1:
-            return ["שאלה מספר", "א.", "ב.", "A"]
-    except:
-        try:
-            indexD = find_index(first_words['text'], "ד.",
-                                ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "ה.", "A"])
-            indexB = find_index(first_words['text'], "ב.",
-                      ["שאלה מספר", "א.", "ב.", "A"])
-            if indexB != -1 and indexD == -1:
-                return ["שאלה מספר", "א.", "ב.", "A"]
-            return ["שאלה מספר", "א.", "ב.", "ג.", "ד.", "A"]
-        except:
-            return ["שאלה מספר", "א.", "ב.", "A"]
Index: UI.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime\r\nimport tkinter as tk\r\nfrom tkinter import ttk,filedialog\r\nimport tkinter.messagebox as messagebox\r\nfrom PIL import Image, ImageTk\r\nimport  AnswerMixer\r\nwindow = tk.Tk()\r\nwindow.title(\"Mixwer\")\r\nwindow.geometry(\"500x500\")\r\nwindow.resizable(False, False)  # Disable resizing\r\n\r\n\r\n\r\n#set background image\r\nbackground_image_path = \"C:\\\\Users\\\\izeik\\\\PycharmProjects\\\\pythonProject1\\\\UI\\\\background.png\"\r\nbackground_image = Image.open(background_image_path)\r\nbackground_photo = ImageTk.PhotoImage(background_image)\r\n\r\nlabel = tk.Label(window, image=background_photo)\r\nlabel.place(x=-2, y=0)\r\n\r\n#set uploadFiles button\r\nuploadButton_image_path = \"C:\\\\Users\\\\izeik\\\\PycharmProjects\\\\pythonProject1\\\\UI\\\\buttonUplodFiles.png\"\r\nuploadButton_photo = ImageTk.PhotoImage(file = uploadButton_image_path)\r\n\r\nuploadFilesButton = ttk.Button(window,image=uploadButton_photo,  command=lambda: print(\"Button clicked!\"))\r\nuploadFilesButton.place(x=500/2 - 270/2, y=400)\r\n\r\ndef UploadFiles_button_click():\r\n    file_paths = filedialog.askopenfilenames(filetypes=[(\"PDF Files\", \"*.pdf\")])\r\n    successFlag = AnswerMixer.main(file_paths)\r\n    if successFlag:\r\n        current_datetime = datetime.now()\r\n        # Format the datetime as a string\r\n        datetime_string = current_datetime.strftime(\"%Y-%m-%d_%H-%M-%S\")\r\n\r\n        zip_path = filedialog.asksaveasfilename(initialfile=\"Mixwer - \"+datetime_string+\".zip\",defaultextension=\".zip\", filetypes=[(\"ZIP Files\", \"*.zip\")])\r\n        AnswerMixer.zipPdf(zip_path)\r\n    #TODO: call AnswerMixer main. at the end ask user where to save the zip\r\nuploadFilesButton.configure(command=UploadFiles_button_click)\r\n\r\nwindow.mainloop()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/UI.py b/UI.py
--- a/UI.py	(revision 3e0c8c7441fe1172d8d7e414429550ea7c8bf62f)
+++ b/UI.py	(date 1703961005709)
@@ -1,9 +1,10 @@
 from datetime import datetime
 import tkinter as tk
 from tkinter import ttk,filedialog
-import tkinter.messagebox as messagebox
 from PIL import Image, ImageTk
-import  AnswerMixer
+
+import FunctionalScripts.functionalFiles
+import  Main
 window = tk.Tk()
 window.title("Mixwer")
 window.geometry("500x500")
@@ -12,7 +13,7 @@
 
 
 #set background image
-background_image_path = "C:\\Users\\izeik\\PycharmProjects\\pythonProject1\\UI\\background.png"
+background_image_path = r'Used Png\UI\background.png'
 background_image = Image.open(background_image_path)
 background_photo = ImageTk.PhotoImage(background_image)
 
@@ -20,7 +21,7 @@
 label.place(x=-2, y=0)
 
 #set uploadFiles button
-uploadButton_image_path = "C:\\Users\\izeik\\PycharmProjects\\pythonProject1\\UI\\buttonUplodFiles.png"
+uploadButton_image_path = r"Used Png\UI\buttonUplodFiles.png"
 uploadButton_photo = ImageTk.PhotoImage(file = uploadButton_image_path)
 
 uploadFilesButton = ttk.Button(window,image=uploadButton_photo,  command=lambda: print("Button clicked!"))
@@ -28,14 +29,15 @@
 
 def UploadFiles_button_click():
     file_paths = filedialog.askopenfilenames(filetypes=[("PDF Files", "*.pdf")])
-    successFlag = AnswerMixer.main(file_paths)
+    array_paths,successFlag = Main.main(file_paths)
     if successFlag:
         current_datetime = datetime.now()
         # Format the datetime as a string
         datetime_string = current_datetime.strftime("%Y-%m-%d_%H-%M-%S")
 
         zip_path = filedialog.asksaveasfilename(initialfile="Mixwer - "+datetime_string+".zip",defaultextension=".zip", filetypes=[("ZIP Files", "*.zip")])
-        AnswerMixer.zipPdf(zip_path)
+
+        FunctionalScripts.functionalFiles.zipPdf(array_paths,zip_path)
     #TODO: call AnswerMixer main. at the end ask user where to save the zip
 uploadFilesButton.configure(command=UploadFiles_button_click)
 
